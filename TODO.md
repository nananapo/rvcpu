●現状
①IF / MEM
↓↑
②MemoryInterface
↓↑
③MemoryUnalignedAccessController (MEMORY_DISALLOW_UNALIGNEDの時はスキップ)
↓↑
④MemoryMapController
↓↑
⑤MemoryMappedIO_Uart_tx / MemoryMappedIO_Uart_rx / MemoryMapped_MachineTimeRegister / Memory(UARTMemory)


④ただのセレクタなので、最速で改善の余地はない
⑤最速。TangNano9k上のBSRAMを使ってるだけ。
　しかし、外部のディスクを使っていないことに文句が非常に非常にある。キャッシュもないしさ

③Unalignedといいつつ、バイト、ハーフワード命令の対応を兼ねる。(これは必要である)
　バイト、ハーフワード命令をサポートしないわけにはいかないので必要だが、ワード命令を遅くしないように気を付けたい。今は遅い。
　そもそも、この分け方が良いものなのかわからない。
　命令読み込みは必ず4byte-alignにする(Cでも)ので、これを通す必要はないと思われる。

②命令読み込みとデータ読み込みの両方のワイヤを受け、いい感じにメモリにつなぐ。アラインされているのは③を挟まないようにしたい。
①一応問題はないはず。

●理想

1. 外部の大容量なRAMを使う

　IPのSDRAMControllerを使う。これを作るのはあまり意味がないと思うので、作らないで使う。

2. データについて、キャッシュを挟む

　キャッシュラインというやつを実装する。何アソシアティブにするかはお悩み。

3. 命令のキャッシュミスがない限り、ほぼ毎クロック命令を供給したい
3.a キャッシュを実装する

　どういう形式でキャッシュするかはお悩み。

3.b メモリ側から命令をバンバン送ってほしい

　もはや、フェッチのたびにIFステージからメモリに命令を送りたくない。
　メモリからIFにメモリを送り、変更する際に命令を送るようにしたい。

4. IF / MEM - メモリの間のreq/respをキューにする。

　直接つなぎたくない。つらすぎるよ～


●じゃあ、タスクを定義して分割しよう

スキップ(後回しにできる)
    IPのSDRAM Controllerを入れる。
    SDRAM Controllerの使い方を調べる。
    SDRAMへの命令の書き込み方を調べる。

命令をメモリから送り続けるようにする。

OK req, respのキューを作る。
IFからアドレス変更のリクエストを送れるようにする。
IFからreq, respのキューをリセットできるようにする。
キャッシュを実装する。
reqするとき、見つかったらそのまま。フラグを変化させる。
見つからなかったらリクエストしてからキャッシュする。
書き込みは追い出し時のみ。明示的にすべて反映する命令は欲しいが、優先度低め。



たいへんになってきた。

命令メモリとデータメモリは分けたくないお気持ちなのでどうするか...

命令の連続発行はどうしよう
何をしたいかというと、データストールかなんかでIFが止まってても命令をフェッチし続けたい。
この処理をどこにどう書くかお悩み

Memory
|
MemMap
|
MemUnaligned
|
MemInterface

要するに、MemMap以降を使い切りたい。ウーン

データだけMemUnalignedの機能を通せばいいな。つまり、
        レMemory
            |
        レMemMap
            |
        MemInterface
            |
レMemUnaligned----InstQueue(Issuer)
|                   |
レMEM Stage         レIFstage

これが良い


IFStageを消した。IFStageの役割が、

* IDがストールしていないときはqueueを見て流して、
* ブランチするとき、成功したなら無視、失敗ならreq

する程度になってしまい(これは良いこと)、もはやFetchStage.svファイルに書くまでもないものになった

うーん。MemInterfaceには、InnstIssuerを待つまでもなくどんどん命令をフェッチしていってほしい。ならつまり、InstQueueのアドレスとMemInterfaceを直結するしかないか